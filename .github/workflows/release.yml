name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'stable'
        type: choice
        options:
        - stable
        - beta
        - nightly
        - dev
      version_override:
        description: 'Manual version (leave empty for auto-increment, e.g. 2025.12.3b1). Do not add v in front.'
        required: false
        default: ''
        type: string

permissions:
  contents: write
  packages: write

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.version }}
      commit_sha: ${{ steps.commit.outputs.commit_sha }}
    steps:
    - uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.14'

    - name: Calculate Version
      id: version
      run: |
        # Get current version from frontend/package.json (Source of Truth)
        current=$(jq -r .version frontend/package.json)

        # Use input release type (stable/beta/nightly/dev)
        RELEASE_TYPE="${{ inputs.release_type }}"

        # Check for manual version override
        if [ -n "${{ inputs.version_override }}" ]; then
          new_version="${{ inputs.version_override }}"
        else
          # Auto-generate version using the refined script
          new_version=$(python3 scripts/generate_version.py --current "$current" --type $RELEASE_TYPE)
        fi

        echo "Release Type: $RELEASE_TYPE"
        echo "Current Version: $current"
        echo "New Version: $new_version"

        echo "NEW_VERSION=$new_version" >> $GITHUB_ENV
        echo "RELEASE_TYPE=$RELEASE_TYPE" >> $GITHUB_ENV
        echo "version=$new_version" >> $GITHUB_OUTPUT

    - name: Update Version Files & Commit
      id: commit
      run: |
        # Configure Git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        # Update frontend/package.json
        cd frontend
        # Sanitize for NPM (Strict SemVer: .dev -> -dev, b1 -> -b1)
        NPM_VERSION=$(echo "${{ env.NEW_VERSION }}" | sed -E 's/([0-9])([ab])/\1-\2/' | sed 's/\.dev/-dev/')
        npm version $NPM_VERSION --no-git-tag-version --allow-same-version
        cd ..

        # Update backend/app/core/config.py
        sed -i 's/os.getenv("BACKEND_VERSION", "[^"]*")/os.getenv("BACKEND_VERSION", "${{ env.NEW_VERSION }}")/' backend/app/core/config.py
        sed -i 's/os.getenv("RELEASE_TYPE", "[^"]*")/os.getenv("RELEASE_TYPE", "${{ env.RELEASE_TYPE }}")/' backend/app/core/config.py

        # Update frontend/src/config.js
        sed -i 's/export const APP_RELEASE_TYPE = "[^"]*";/export const APP_RELEASE_TYPE = "${{ env.RELEASE_TYPE }}";/' frontend/src/config.js

        # Update README Statistics
        python3 scripts/update_readme_stats.py

        # Commit and Push
        git add frontend/package.json backend/app/core/config.py frontend/src/config.js README.md
        git commit -m "chore(release): bump version to ${{ env.NEW_VERSION }} [skip ci]"
        git push

        # Get the new commit SHA
        echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

    - name: Find Last Stable Tag
      id: last_stable
      if: inputs.release_type == 'stable'
      run: |
        # Find the last stable tag (no 'a', 'b', 'dev', 'nightly' suffix)
        LAST_STABLE=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -vE '[ab][0-9]|dev|nightly' | sort -V | tail -1)
        echo "Last stable tag: $LAST_STABLE"
        echo "last_stable=$LAST_STABLE" >> $GITHUB_OUTPUT

    - name: Generate Changelog (Stable)
      id: changelog_stable
      if: inputs.release_type == 'stable'
      uses: orhun/git-cliff-action@v4
      with:
        config: cliff.toml
        args: --verbose --unreleased --tag v${{ env.NEW_VERSION }} ${{ steps.last_stable.outputs.last_stable && format('--since-tag {0}', steps.last_stable.outputs.last_stable) || '' }}
      env:
        OUTPUT: CHANGELOG.md

    - name: Generate Changelog (Pre-release)
      id: changelog_prerelease
      if: inputs.release_type != 'stable'
      uses: orhun/git-cliff-action@v4
      with:
        config: cliff.toml
        args: --verbose --latest
      env:
        OUTPUT: CHANGELOG.md

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ env.NEW_VERSION }}
        name: Release v${{ env.NEW_VERSION }}
        target_commitish: ${{ steps.commit.outputs.commit_sha }}
        body_path: CHANGELOG.md
        draft: false
        prerelease: ${{ inputs.release_type != 'stable' }}

  build-push-docker:
    needs: release
    uses: ./.github/workflows/docker-publish.yml
    with:
      version: ${{ needs.release.outputs.new_version }}
    permissions:
      contents: read
      packages: write

  build-android:
    needs: release
    uses: ./.github/workflows/android-release.yml
    with:
      tag_name: v${{ needs.release.outputs.new_version }}
      ref: ${{ needs.release.outputs.commit_sha }}
    secrets: inherit

  build-ios:
    needs: release
    uses: ./.github/workflows/ios-release.yml
    with:
      tag_name: v${{ needs.release.outputs.new_version }}
      ref: ${{ needs.release.outputs.commit_sha }}
    secrets: inherit

  check-windows-build-status:
    needs: release
    runs-on: ubuntu-latest
    # Skip this check if this release workflow was manually triggered
    if: github.event_name != 'workflow_dispatch'
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
    steps:
      - name: Check last automatic Windows build status
        id: check
        run: |
          # Get the last workflow run triggered by workflow_call (automatic, from release.yml)
          # We exclude workflow_dispatch (manual) runs
          RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/windows-release.yml/runs?per_page=20")

          # Check if we found any runs
          TOTAL_COUNT=$(echo "$RESPONSE" | jq -r '.total_count // 0')
          if [ "$TOTAL_COUNT" -eq "0" ]; then
            echo "No previous runs found. Building Windows."
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find the last automatic run (workflow_call event, not workflow_dispatch)
          LAST_RUN=$(echo "$RESPONSE" | jq -r '.workflow_runs[] | select(.event == "workflow_call") | .id' | head -n 1)

          if [ -z "$LAST_RUN" ] || [ "$LAST_RUN" == "null" ]; then
            echo "No previous automatic runs found. Building Windows."
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get the status of the last automatic run
          RUN_DETAILS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LAST_RUN")
          RUN_STATUS=$(echo "$RUN_DETAILS" | jq -r '.conclusion')
          RUN_STATE=$(echo "$RUN_DETAILS" | jq -r '.status')

          echo "Last automatic Windows build run ID: $LAST_RUN"
          echo "Last automatic Windows build status: $RUN_STATUS (state: $RUN_STATE)"

          # If the run is still in progress, allow building
          if [ "$RUN_STATE" != "completed" ]; then
            echo "Last automatic run is still in progress. Building Windows."
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "$RUN_STATUS" == "success" ]; then
            echo "Last automatic run was successful. Building Windows."
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Last automatic run failed (status: $RUN_STATUS). Skipping Windows build."
            echo "Build will be skipped until manually triggered and successful."
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

  build-windows:
    needs: [release, check-windows-build-status]
    # Always build if manually triggered, otherwise check the status from check-windows-build-status
    if: |
      github.event_name == 'workflow_dispatch' ||
      (needs.check-windows-build-status.result == 'success' && needs.check-windows-build-status.outputs.should_build == 'true') ||
      (needs.check-windows-build-status.result == 'skipped')
    uses: ./.github/workflows/windows-release.yml
    with:
      tag_name: v${{ needs.release.outputs.new_version }}
      ref: ${{ needs.release.outputs.commit_sha }}
    secrets: inherit

  bump-dev-version:
    needs: release
    runs-on: ubuntu-latest
    # if: inputs.release_type == 'stable' # Only bump main to dev after a stable release
    steps:
      - uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.14'

      - name: Calculate Next Dev Version
        id: dev_version
        env:
          CURRENT_RELEASE: ${{ needs.release.outputs.new_version }}
        run: |
          # The current released version is in CURRENT_RELEASE (e.g. 2025.12.1)
          echo "Released Version: $CURRENT_RELEASE"

          # Use the script to generate the next dev version properly
          NEXT_DEV=$(python3 scripts/generate_version.py --current "$CURRENT_RELEASE" --type dev)

          echo "Next Dev Version: $NEXT_DEV"
          echo "next_dev=$NEXT_DEV" >> $GITHUB_OUTPUT

      - name: Update to Dev Version
        env:
          NEW_VERSION: ${{ steps.dev_version.outputs.next_dev }}
        run: |
          # Configure Git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Update frontend/package.json
          cd frontend
          # Sanitize for NPM (Strict SemVer: .dev -> -dev, b1 -> -b1)
          NPM_VERSION=$(echo "${{ env.NEW_VERSION }}" | sed -E 's/([0-9])([ab])/\1-\2/' | sed 's/\.dev/-dev/')
          npm version $NPM_VERSION --no-git-tag-version --allow-same-version
          cd ..

          # Update backend/app/core/config.py
          sed -i 's/os.getenv("BACKEND_VERSION", "[^"]*")/os.getenv("BACKEND_VERSION", "${{ env.NEW_VERSION }}")/' backend/app/core/config.py
          sed -i 's/os.getenv("RELEASE_TYPE", "[^"]*")/os.getenv("RELEASE_TYPE", "dev")/' backend/app/core/config.py

          # Update frontend/src/config.js
          sed -i 's/export const APP_RELEASE_TYPE = "[^"]*";/export const APP_RELEASE_TYPE = "dev";/' frontend/src/config.js

          # Commit and Push (with rebase to handle concurrent changes from release job)
          git add frontend/package.json backend/app/core/config.py frontend/src/config.js
          git commit -m "chore: prepare for next development iteration ${{ env.NEW_VERSION }} [skip ci]"
          git pull --rebase origin main
          git push origin main
