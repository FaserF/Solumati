name: PR Assistant

on:
  workflow_run:
    workflows: ["Main CI"]
    types:
      - completed
  pull_request_target:
    types:
      - closed

permissions:
  pull-requests: write
  contents: write
  issues: write

jobs:
  # 1. PROCESS RESULTS (Auto-Label, Feedback, Auto-Merge)
  process-results:
    if: ${{ github.event_name == 'workflow_run' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifacts
        uses: actions/github-script@v8
        with:
          script: |
            // Get the PR number associated with the Quality Gate run
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            // (In a real scenario we'd pass the PR number via artifacts,
            // but here we simplify by assuming we can look it up or purely trust the status)

            let conclusion = context.payload.workflow_run.conclusion;
            let pr = context.payload.workflow_run.pull_requests[0];

            if (!pr) {
              console.log("No PR found for this run (maybe push to branch?)");
              return;
            }

            if (conclusion === 'success') {
              console.log("‚úÖ Quality Gate Passed!");

              // 1. Add "Verified" Label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['verified', 'quality-gate-passed']
              });

              // 2. CHECK IF ADMIN -> AUTO MERGE
              // We need to fetch the PR details to see the author
              let prDetails = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              let author = prDetails.data.user.login;
              // Add your admin usernames here
              const ADMINS = ['FaserF', 'SolumatiBot'];

              if (ADMINS.includes(author)) {
                  console.log(`üöÄ Author ${author} is Admin. Auto-merging...`);
                  try {
                      await github.rest.pulls.merge({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: pr.number,
                          merge_method: 'squash'
                      });
                  } catch (e) {
                      console.log("Auto-merge failed (maybe conflicts?): " + e);
                  }
              } else {
                  console.log(`Author ${author} is not Admin. Ready for manual review.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: "‚úÖ **Quality Gate Passed!**\n\nYour code has passed all tests and link checks. A maintainer will review it shortly."
                  });
              }

            } else {
              console.log("‚ùå Quality Gate Failed!");

              try {
                  // Fetch the specific jobs that failed
                  const { data: runJobs } = await github.rest.actions.listJobsForWorkflowRun({
                     owner: context.repo.owner,
                     repo: context.repo.repo,
                     run_id: context.payload.workflow_run.id
                  });

                  let failedJobs = runJobs.jobs.filter(j => j.conclusion === 'failure');
                  let message = "‚ùå **Checks Failed**\n\nThe automation detected issues in the following QA checks:\n\n";

                  // --- AI ERROR SUMMARY GENERATION ---
                  let aiSummary = "\n## ü§ñ AI Error Summary\n_Copy the block below and paste it to your AI assistant to get fixes._\n\n```text\n";
                  aiSummary += "================================================================================\n";
                  aiSummary += "                       CI FAILURE REPORT                                      \n";
                  aiSummary += "================================================================================\n";
                  aiSummary += `REPOSITORY: ${context.repo.owner}/${context.repo.repo}\n`;
                  aiSummary += `PR NUMBER:  ${pr.number}\n`;
                  aiSummary += `TIMESTAMP:  ${new Date().toISOString()}\n\n`;
                  aiSummary += "INSTRUCTIONS FOR AI:\n";
                  aiSummary += "The following errors were detected in the CI pipeline. Please analyze them and\n";
                  aiSummary += "provide the corrected code or instructions to fix these issues.\n\n";

                  let hasAnnotations = false;

                  // Use for...of to allow await inside loop
                  for (const job of failedJobs) {
                      message += `### üî¥ [${job.name}](${job.html_url})\n`;
                      if(job.steps) {
                          job.steps.filter(s => s.conclusion === 'failure').forEach(step => {
                             message += `- **Step: ${step.name}** failed.\n`;
                          });
                      }
                      message += "\n";

                      aiSummary += "--------------------------------------------------------------------------------\n";
                      aiSummary += `JOB FAILURE: ${job.name}\n`;
                      aiSummary += "--------------------------------------------------------------------------------\n";

                      // List Failed Steps
                      if(job.steps) {
                          const failedSteps = job.steps.filter(s => s.conclusion === 'failure');
                          if (failedSteps.length > 0) {
                             aiSummary += "FAILED STEPS:\n";
                             failedSteps.forEach(step => {
                                 aiSummary += `  - ${step.name}\n`;
                             });
                             aiSummary += "\n";
                          }
                      }

                      // Fetch Annotations
                      try {
                        const { data: annotations } = await github.rest.checks.listAnnotations({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            check_run_id: job.id
                        });

                        if (annotations.length > 0) {
                            hasAnnotations = true;
                            aiSummary += "ANNOTATIONS (Specific Line Errors):\n";
                            annotations.forEach(ann => {
                                aiSummary += `  [FILE] ${ann.path}:${ann.start_line}:${ann.start_column || 0}\n`;
                                aiSummary += `  [TYPE] ${ann.annotation_level} | ${ann.title || 'Error'}\n`;
                                aiSummary += `  [DESC] ${ann.message}\n`;
                                if (ann.raw_details) {
                                    aiSummary += `  [DTLS] ${ann.raw_details}\n`;
                                }
                                aiSummary += "  ---\n";
                            });
                        } else {
                            aiSummary += "NO DIRECT ANNOTATIONS FOUND.\n";
                            aiSummary += "(The error might be a general crash or timeout. Check the full logs via the links above.)\n";
                        }
                      } catch (annErr) {
                          aiSummary += `ERROR FETCHING ANNOTATIONS: ${annErr}\n`;
                      }
                      aiSummary += "\n"; // Spacing between jobs
                  }

                  aiSummary += "================================================================================\n";
                  aiSummary += "END OF REPORT\n";
                  aiSummary += "```\n";

                  // Only append if we actually found something meaningful or if jobs failed
                  // (Always append if jobs failed, which is true here)
                  message += aiSummary;

                  message += "\n---\n> **Action Required**:\n> 1. Copy the report above.\n> 2. Paste it to your AI coding assistant.\n> 3. Apply the suggested fixes.";

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    labels: ['tests-failed']
                  });

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: message
                  });

              } catch(err) {
                  console.log("Error generating detailed report: " + err);
                  // Fallback to simple message
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: "‚ùå **Checks Failed**\n\nThe automation detected issues. Please check the 'Main CI' action logs for details."
                  });
              }
            }

  # 2. THANK YOU MESSAGE (On Merge)
  thank-contributor:
    if: ${{ github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    steps:
      - name: Say Thanks
        uses: actions/github-script@v8
        with:
          script: |
            const ADMINS = ['FaserF', 'SolumatiBot'];
            const author = context.payload.pull_request.user.login;

            if (!ADMINS.includes(author) && !author.endsWith('[bot]')) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `üéâ **Merged!**\n\nThank you @${author} for your contribution to Solumati! Your effort helps make this project better for everyone. ‚ù§Ô∏è`
                });
            }
