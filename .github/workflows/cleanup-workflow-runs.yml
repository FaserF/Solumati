name: Cleanup Workflow Runs

on:
  schedule:
    - cron: '0 3 * * 0'  # Weekly, Sundays at 3:00 AM UTC
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (only log, do not delete)'
        required: false
        default: 'false'
        type: boolean

permissions:
  actions: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup old workflow runs
        uses: actions/github-script@v8
        with:
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Configuration
            const KEEP_RUNS_PER_WORKFLOW = 10;
            const KEEP_DAYS = 7;
            const DELETE_FAILED_AFTER_DAYS = 14;

            const now = new Date();
            const keepUntil = new Date(now - KEEP_DAYS * 24 * 60 * 60 * 1000);
            const deleteFailedAfter = new Date(now - DELETE_FAILED_AFTER_DAYS * 24 * 60 * 60 * 1000);

            console.log(`ðŸ§¹ Cleanup Configuration:`);
            console.log(`   - Keep last ${KEEP_RUNS_PER_WORKFLOW} runs per workflow`);
            console.log(`   - Keep all runs from last ${KEEP_DAYS} days`);
            console.log(`   - Delete failed runs older than ${DELETE_FAILED_AFTER_DAYS} days`);
            console.log(`   - Dry run: ${dryRun}`);
            console.log('');

            // Get all workflows
            const workflows = await github.paginate(github.rest.actions.listRepoWorkflows, {
              owner,
              repo,
            });

            let totalDeleted = 0;
            let totalKept = 0;

            for (const workflow of workflows) {
              console.log(`\nðŸ“‹ Processing: ${workflow.name}`);

              // Get runs for this workflow
              const runs = await github.paginate(github.rest.actions.listWorkflowRuns, {
                owner,
                repo,
                workflow_id: workflow.id,
              });

              // Sort by created_at descending (newest first)
              runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

              let keptCount = 0;

              for (const run of runs) {
                const runDate = new Date(run.created_at);
                const isRecent = runDate > keepUntil;
                const isKeptByCount = keptCount < KEEP_RUNS_PER_WORKFLOW;
                const isTaggedRelease = run.head_branch?.startsWith('v') || run.event === 'release';
                const isOldFailed = run.conclusion === 'failure' && runDate < deleteFailedAfter;

                // Keep if: recent OR in top N OR is a release
                const shouldKeep = (isRecent || isKeptByCount || isTaggedRelease) && !isOldFailed;

                if (shouldKeep) {
                  keptCount++;
                  totalKept++;
                } else {
                  totalDeleted++;
                  if (dryRun) {
                    console.log(`   [DRY RUN] Would delete: #${run.run_number} (${run.created_at}) - ${run.conclusion}`);
                  } else {
                    console.log(`   ðŸ—‘ï¸ Deleting: #${run.run_number} (${run.created_at}) - ${run.conclusion}`);
                    await github.rest.actions.deleteWorkflowRun({
                      owner,
                      repo,
                      run_id: run.id,
                    });
                  }
                }
              }
            }

            console.log(`\nâœ… Summary:`);
            console.log(`   - Kept: ${totalKept} runs`);
            console.log(`   - Deleted: ${totalDeleted} runs`);
